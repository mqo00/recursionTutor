// productionrules for recursionTutor

// subgoal              correct rules           hint/buggy rules
// inputLineNum         enterLineNum            buggyLineNum, lineToCallHint 
// inputCallStack       enterArgs; enterBC      buggyBC
// inputReturnVal       enterReturn             buggyReturn

// TODO: SRL reflection hint msg at BC step & return 1st step?

import("RT_types.nools");

rule bootstrap {
	when {
		s: Boolean s === false from false;
	}
	then {
		let cols = ["lineNumbers", "callStackCol", "baseCaseCol", "returnValCol"];
        var cellName, cellVal, cellCol; 
        for (let col = 0; col < cols.length; col++) {
            let cellNameList=[];
            cellVal = null;
            cellCol = cols[col];
            if (col == 0) {
                for (let lineName in lineInput) {
                    cellNameList.push(lineName);
                    assert(new Cell(lineName, cellVal, -1, cellCol));
                }
            } else {
                for (let row = 0; row < bcLine + 1; row++) {
                    // cellName e.g., callStackCol.R0C0, baseCaseCol.R2C2
                    cellVal=null;
                    cellName = cols[col] + ".R" + row + "C0"; 
                    if (row == 0 && col == 1) { // first input val
                        cellVal = inputArgs[row];
                    }
                    cellNameList.push(cellName);
                    assert(new Cell(cellName, cellVal, row, cellCol));
                    if (cellVal != null) {
                        assert(new TPA(cellName, "UpdateTextField", cellVal));
                    }
                }
            }
            let visible = col < 3 ? true : false;
            assert(new Column(cellCol, cellNameList, visible));
            assert(new TPA(cellCol, "setVisible", visible));
        }
        assert(new Problem(funcName+inputArgs[0], false));
        assert(new TPA("probDscp", "UpdateTextArea", prompt1+"="+prompt2+"="+prompt3));
        assert(new TPA("probCode", "UpdateTextArea", code1+"=="+code2+"=="+code3+"/\/"+code4+"/\/"+code5));
        assert(new TPA("step2Tag", "setVisible", false));
        assert(new TPA("returnValColTag", "setVisible", false));
        assert(new TPA("funcNameCol.R0C0", "UpdateTextArea", funcName+"(                     )")); 

		setProblemAttribute("use_backtracking", true);
		halt();
	}
}

// enterLineNum
// If subGoal == "inputLineNum", there're >=1 out of 4 linNumInput box empty
//  And student enter correct lineNum for an empty input box
// Then update the value at input box interface & WM
//  And If lineNumbers Column has no cell with empty value
//      update subgoal to "inputCallStack"
//      init curStep to be ["callStackCol", 1] 
//          with scaffolding: row start from 1, not 0 (filled by tutor)
//      show step label, instruction for step2
rule enterLineNum {
    when {
        p: Problem p.subGoal === "inputLineNum";
        c: Cell c.colName == "lineNumbers" && !c.value {name: sel};
        c2: Cell c2.colName == "lineNumbers" && c2.name != sel;
        c3: Cell c3.colName == "lineNumbers" && c3.name != sel && c3.name != c2.name;
        c4: Cell c4.colName == "lineNumbers" && c4.name != sel && c4.name != c3.name && c4.name != c2.name;
    }
    then {
        if (checkSAI({selection: sel, action: "UpdateTextField", input: lineInput[sel]})) {
            modify(c, "value", lineInput[sel]);
            // switch from inputLineNum to inputCallStack
            if (c.value && c2.value && c3.value && c4.value) {
                modify(p, "subGoal", "inputCallStack");
                modify(p, "curStep", ["callStackCol", 1]);
                // show step 2 title & instruction
                assert(new TPA("step2Tag", "setVisible", true));
                assert(new TPA("step2Dscp", "UpdateTextArea", instruction[0]));
                assert(new TPA("funcNameCol.R1C0", "UpdateTextArea", funcName+"(                     )"));
            }
            halt();
        } else {
            backtrack();
        }
    }
}

// lineToCallHint
// If subGoal == "inputCallStack" and student haven't been filled first step
// Then display hint for call stack
rule lineToCallHint {
    when {        
        p: Problem p.subGoal === "inputCallStack";
        c: Cell c.colName == "callStackCol" && c.rowNum == 1 && !c.value;
    }
    then {
        assert(new Hint("Good job! Start work on the call stack column now!"));
    }
}


// enterArgs
// If subGoal == "inputCallStack", row = curStep[1] <= bcLine
//  And all cells at callStackCol w/ rowNum < row has value (inherently met)
//  And student enter correct arg that match inputArgs[row] at callStackCol
// Then update the value at table callStackCol & row, curStep row++
rule enterArgs {
    when {
        p: Problem p.subGoal === "inputCallStack" && p.curStep[1] <= bcLine 
            {curStep: step};
        c: Cell c.colName == "callStackCol" && c.rowNum == step[1] && !c.value 
            {name: sel};
    }
    then {
        let row = step[1];
        let nrow = row+1;
        console.log("current row: "+row);
         // inputArgs[row] should be UpdateTextArea (not TextField)
        if (checkSAI({selection: sel, action: "UpdateTextArea", input: inputArgs[row] })) {
            modify(c, "value", inputArgs[row]);
            modify(p, "curStep", ["callStackCol", nrow]);
            assert(new TPA("funcNameCol.R"+nrow+"C0", "UpdateTextArea", funcName+"(                     )"));

            halt();
        } else {
            backtrack();
        }
    }
}

function cmpLowerBC(s, t) {
    return s.selection == t.selection && s.input.toLowerCase() == "bc";
}

// enterBC
// If subGoal == "inputCallStack", curStep[1] == bcLine+1
//  And all cells at callStackCol w/ rowNum <= bcLine has value (inherently met)
//  And student enter "bc/BC" at bcLine & baseCaseCol
// Then update the value at table baseCaseCol & bcLine to "BC"
//  update subgoal to "inputReturnVal", curStep to ["returnValCol", bcLine]
//  update instruction, set returnValCol visible to true 
rule enterBC {
    when { // curStep is actually the next row of bcLine
        p: Problem p.subGoal === "inputCallStack" && p.curStep[1] == bcLine+1 ;
        bc: Cell bc.colName == "baseCaseCol" && bc.rowNum == bcLine {name: sel};
        col: Column col.name == "returnValCol";
    }
    then {
        var ans = "bc"; // pass in comparator, or check StudentValues
        var SAI = {selection: sel, action: "UpdateTextArea", input: ans};
        if (checkSAI(SAI,  cmpLowerBC)) {
            modify(bc, "value", ans);

            assert(new Hint("Good job! Start work on the return value column now!"));
            modify(p, "subGoal", "inputReturnVal");
            modify(p, "curStep", ["returnValCol", bcLine]);

            // update instruction & set retrunValCol to visible 
            modify(col, "visible", true);
            assert(new TPA("step2Dscp", "UpdateTextArea", instruction[1]));
            assert(new TPA("returnValCol", "setVisible", col.visible)); 
            assert(new TPA("returnValColTag", "setVisible", true));
            halt();
        } else {
            backtrack();
        }
    }
}

// enterReturn
// If subGoal == "inputReturnVal", row = curStep[1] <= bcLine
//  And student enter correct return that match returnVal[row] at returnValCol
// Then update the value at table returnValCol & row, curStep row--
//  And if row == 0, update done to true
rule enterReturn {
    when {
        p: Problem p.subGoal === "inputReturnVal" && p.curStep[1] <= bcLine
            {curStep: step}; 
        c: Cell c.colName == "returnValCol" && c.rowNum == step[1] && !c.value 
            {name: sel};
    }
    then {
        let row = step[1];
        console.log(row);
        if (checkSAI({selection: sel, action: "UpdateTextArea", input: returnVal[row]})) {
            modify(c, "value", returnVal[row]);
            modify(p, "curStep", ["returnValCol", row-1]);
            if (row == 0) {
                modify(p, "done", true);
            }
            halt();
        } else {
            backtrack();
        }
    }
}

// buggyLineNum
// TODO: work on actual bug message
rule buggyLineNum {
    when {
        p: Problem p.subGoal === "inputLineNum";
        c: Cell c.colName == "lineNumbers" && !c.value {name: sel};
    }
    then {
        var ans = lineInput[sel];
        var SAI = {selection: sel, action: "UpdateTextField", input: ans};
        if (checkSAI(SAI, function(s, t) {return s.selection == t.selection && s.input != ans;}, true)) {
            setSuccessOrBugMsg("What portion of the code is base case & recursive case?");
        }
        backtrack();
    }
}

// buggyBC scenarios
// (1) callStackCol haven't reach bcLine+1, attempt to check baseCaseCol
// (2) callStackCol go beyond bcLine+1, attempt to fill in more args
//     TODO: currently #rows = len(inputArgs), need global var for table #row
// (3) callStackCol at bcLine+1, check baseCaseCol at row != bcLine
// TODO: update bug messages
rule buggyBC {
    when { // curStep is actually the next row of bcLine
        p: Problem p.subGoal === "inputCallStack";
        bc: Cell bc.colName == "baseCaseCol" && bc.rowNum == bcLine {name: sel};
        sai: StudentValues sai.input != null {selection: sSel, input: sInput};
        sc: Cell sc.colName == "baseCaseCol" && sc.name == sSel &&
            sc.rowNum != bcLine && sc.name != sel ; 
    }
    then {
        if (p.curStep[1] < bcLine+1) {
            setSuccessOrBugMsg("callStackCol haven't reach bcLine, attempt to check baseCaseCol");
        } else if (p.curStep[1] > bcLine+1) {
            setSuccessOrBugMsg("callStackCol go beyond bcLine+1, attempt to fill in more args");
        } else {
            var ans = "bc";
            if (checkSAI({selection: sSel, action: "UpdateTextArea", input: ans},  cmpLowerBC, true)) {
                setSuccessOrBugMsg("callStackCol at bcLine+1, check baseCaseCol at row != bcLine");
            }
            backtrack(); // TODO: this level or next?
        }
    }
}

// buggyReturn scenarios
// (1) start from row 0 of returnValCol instead of row bcLine
// (2) start from row bcLine but wrong base case return value 
// (3) wrong value at curStep row -> off by 1 hard to detect...


rule Done {
	when {
		prob : Problem prob.done === true;
	}
	then {
		if (checkSAI({selection: "done", action: "ButtonPressed", input: "don't_care"})) {
			halt();
		}
	}
}
