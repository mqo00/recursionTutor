

import("RT_types.nools");

rule bootstrap {
	when {
		s: Boolean s === false from false;
	}
	then {
		let cols = ["lineNumbers", "callStackCol", "baseCaseCol", "returnValCol"];
        var cellName, cellVal, cellCol; 
        for (let col = 0; col < cols.length; col++) {
            let cellNameList=[];
            cellVal = null;
            cellCol = cols[col];
            



            if (col == 0) {
                for (let lineName in lineInput) {
                    cellNameList.push(lineName);
                    assert(new Cell(lineName, cellVal, -1, cellCol));
                }
            } else {
                for (let row = 0; row < bcLine + 1; row++) {
                    // cellName e.g., callStackCol.R0C0, baseCaseCol.R2C2
                    cellVal=null;
                    cellName = cols[col] + ".R" + row + "C0"; 
                    if (row == 0 && col == 1) { // first input val
                        cellVal = inputArgs[row];
                    }

                    cellNameList.push(cellName);
                    assert(new Cell(cellName, cellVal, row, cellCol));
                    if (cellVal != null) {
                        // [selection, action, input], sel = cellName
                        assert(new TPA(cellName, "UpdateTextField", cellVal));
                    }

                }
            }
            let visible = col < 3 ? true : false;
            assert(new Column(cellCol, cellNameList, visible));
            assert(new TPA(cellCol, "setVisible", visible));
        }
        // TODO lineInput, inputArgs, returnVal not useful?
        assert(new Problem(problemName, lineInput, inputArgs, returnVal, bcLine, false));
        assert(new TPA("probDscp", "UpdateTextArea", prompt1+"="+prompt2+"="+prompt3));
        assert(new TPA("probCode", "UpdateTextArea", code1+"=="+code2+"=="+code3+"/\/"+code4+"/\/"+code5));
        assert(new TPA("step2Tag", "setVisible", false));
        assert(new TPA("returnValColTag", "setVisible", false));
        assert(new TPA("funcNameCol.R0C0", "UpdateTextArea", "recursiveCount(                     )")); // show function name, can be replaced with a global variable
        assert(new TPA("funcNameCol.R1C0", "UpdateTextArea", "recursiveCount(                     )")); // show function name, can be replaced with a global variable


		setProblemAttribute("use_backtracking", true);
		halt();
	}
}

// subgoal              correct rules           switch/buggy rules
// inputLineNum         enterLineNum            lineToCall      
// inputCallStack       enterArgs; enterBC      buggyBC
// inputReturnVal       enterReturn             buggyReturn

// SRL reflection msg at BC step & return 1st step

// enterLineNum
// If subGoal == "inputLineNum", there're >=1 out of 4 linNumInput box empty
//  And student enter correct lineNum for an empty input box
// Then update the value at input box interface & WM
rule enterLineNum {
    when {
        p: Problem p.subGoal === "inputLineNum";
        c: Cell c.colName == "lineNumbers" && !c.value {name: sel};
    }
    then {
        if (checkSAI({selection: sel, action: "UpdateTextField", input: lineInput[sel]})) {
            modify(c, "value", lineInput[sel]);
            halt();
        } else {
            backtrack();
        }
    }
}

// lineToCall
// If subGoal == "inputLineNum"
//  And lineNumbers Column has no cell with empty value
// Then update subgoal to "inputCallStack"
//  init curStep to be ["callStackCol", 0]
rule lineToCall {
    when {        
        p: Problem p.subGoal === "inputLineNum";
        not (c: Cell c.colName == "lineNumbers" && !c.value);
    }
    then {
        //assert(new TPA("step2Tag", "setVisible", true)); //show step 2 title
        //assert(new TPA("step2Dscp", "UpdateTextArea", instruction[0])); //show instruction for step2
        // ?? appear after fill in a callstack row
        assert(new Hint("Good job! Start work on the call stack column now!"));
        modify(p, "subGoal", "inputCallStack");
        modify(p, "curStep", ["callStackCol", 1]); //row should start from 1, not 0 (first arg filled by tutor)
        //assert(new TPA("funcNameCol.R1C0", "UpdateTextArea", "recursiveCount(                     )")); // show function name, can be replaced with a global variable

        //halt();
    }
}


// shouStep2
// If subGoal == "inputCallStack"
//  And the student has not began step 2
// Then show step label, instruction
rule showStep2 {
    when {        
        p: Problem p.subGoal === "inputCallStack";
        c: Cell c.colName == "callStackCol" && c.rowNum == 1 && !c.value ; //when the second row is not filled in
    }
    then {
        assert(new TPA("step2Tag", "setVisible", true)); //show step 2 title
        assert(new TPA("step2Dscp", "UpdateTextArea", instruction[0])); //show instruction for step2
        // ?? appear after fill in a callstack row
        

        //halt();
    }



}

// enterArgs
// If subGoal == "inputCallStack", row = curStep[1] <= bcLine
//  And all cells at callStackCol w/ rowNum < row has value (inherently met)
//  And student enter correct arg that match inputArgs[row] at callStackCol
// Then update the value at table callStackCol & row, curStep row++
rule enterArgs {
    when {
        p: Problem p.subGoal === "inputCallStack" && p.curStep[1] <= bcLine 
            {curStep: step};
        c: Cell c.colName == "callStackCol" && c.rowNum == step[1] && !c.value 
            {name: sel};
    }
    then {
        let row = step[1];
        let nrow = row+1;
        console.log("current row: "+row);
        if (checkSAI({selection: sel, action: "UpdateTextArea", input: inputArgs[row] })) { //inputArgs[row] should be UpdateTextArea (not TextField)
            modify(c, "value", inputArgs[row]);
            modify(p, "curStep", ["callStackCol", nrow]);
            assert(new TPA("funcNameCol.R"+nrow+"C0", "UpdateTextArea", "recursiveCount(                     )")); // show function name, can be replaced with a global variable

            halt();
        } else {
            backtrack();
        }
    }
}

// enterBC
// If subGoal == "inputCallStack", curStep[1] == bcLine
//  And all cells at callStackCol w/ rowNum <= bcLine has value (inherently met)
//  And student enter "bc/BC" at bcLine & baseCaseCol
// Then update the value at table baseCaseCol & bcLine to "BC"
//  update subgoal to "inputReturnVal", curStep to ["returnValCol", bcLine]
//  set returnValCol visible to true 
rule enterBC {
    when {
        p: Problem p.subGoal === "inputCallStack" && p.curStep[1] == bcLine+1 ; //curStep is actually the next row of bcLine
        bc: Cell bc.colName == "baseCaseCol" && bc.rowNum == bcLine {name: sel};
        col: Column col.name == "returnValCol";
    }
    then {
        var ans = "bc"; // pass in comparator, or check StudentValues https://github.com/CMUCTAT/CTAT/wiki/JavaScript-Model-Tracer#evaluating-student-input
        var SAI = {selection: sel, action: "UpdateTextArea", input: ans};
        if (checkSAI(SAI, function(s, t) {return s.selection == t.selection && s.input.toLowerCase() == ans;})) {
            modify(bc, "value", ans);

            assert(new Hint("Good job! Start work on the return value column now!"));
            modify(p, "subGoal", "inputReturnVal");
            modify(p, "curStep", ["returnValCol", bcLine]);
            assert(new TPA("step2Dscp", "UpdateTextArea", instruction[1]));

            modify(col, "visible", true);
            assert(new TPA("returnValCol", "setVisible", col.visible)); //set retrunValCol to visible
            assert(new TPA("returnValColTag", "setVisible", true));

            halt();
        } else {
            backtrack();
        }
    }
}

// enterReturn
// If subGoal == "inputReturnVal", row = curStep[1] <= bcLine
//  And student enter correct return that match returnVal[row] at returnValCol
// Then update the value at table returnValCol & row, curStep row--
//  And if row == 0, update done to true
rule enterReturn {
    when {
        p: Problem p.subGoal === "inputReturnVal" && p.curStep[1] <= bcLine
            {curStep: step}; 
        c: Cell c.colName == "returnValCol" && c.rowNum == step[1] && !c.value 
            {name: sel};
    }
    then {
        let row = step[1];
        console.log(row);
        if (checkSAI({selection: sel, action: "UpdateTextArea", input: returnVal[row]})) {
            modify(c, "value", returnVal[row]);
            modify(p, "curStep", ["returnValCol", row-1]);
            if (row == 0) {
                modify(p, "done", true);
            }
            halt();
        } else {
            backtrack();
        }
    }
}

// buggyBC scenarios
// (1) callStackCol haven't reach bcLine, attempt to check baseCaseCol
// (2) callStackCol go beyond bcLine, attempt to fill in more args
//     TODO: currently #rows = len(inputArgs), need global var for table #row
// (3) callStackCol at bcLine, check baseCaseCol at row != bcLine

// If curStep[1] != bcLine

// buggyReturn scenarios
// (1) start from row 0 of returnValCol instead of row bcLine
// (2) start from row bcLine but wrong base case return value 
// (3) wrong value at curStep row -> off by 1 hard to detect...


rule Done {
	when {
		prob : Problem prob.done === true;
	}
	then {
		if (checkSAI({selection: "done", action: "ButtonPressed", input: "don't_care"})) {
			halt();
		}
	}
}
